
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Showdown</title>


</head>
<body>
    <h1>Sudoku Showdown</h1>
    <div id="score"></div>
    <div id="timer">Time: 0s</div>
    <div id="incorrect-attempts">Mistakes: 0</div>
    <div id="sudoku-board" class="sudoku-container"></div>
    <div class="number-selector">
        <div id="tips-button">Select:</div>
        <button class="number-button" data-number="1">1</button>
        <button class="number-button" data-number="2">2</button>
        <button class="number-button" data-number="3">3</button>
        <button class="number-button" data-number="4">4</button>
        <button class="number-button" data-number="5">5</button>
        <button class="number-button" data-number="6">6</button>
        <button class="number-button" data-number="7">7</button>
        <button class="number-button" data-number="8">8</button>
        <button class="number-button" data-number="9">9</button>
    </div>
    <button id="draft-button">Draft</button>
    <button id="hint-button">Hint</button>
    <button id="restart-button">Restart</button>

    <script>
        ////// Function to generate a valid Sudoku board with seed
        function generateSudoku() {
            const board = Array.from({ length: 9 }, () => Array(9).fill(''));

            function isValid(board, row, col, num) {
                for (let i = 0; i < 9; i++) {
                    if (board[row][i] == num || board[i][col] == num ||
                        board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + i % 3] == num) {
                        return false;
                    }
                }
                return true;
            }

        // Create a seeded random generator
            function createSeededRandom(seed) {
                let s = seed % 2147483647;
                if (s <= 0) s += 2147483646;

                return function() {
                    s = (s * 16807) % 2147483647;
                    return (s - 1) / 2147483646;
                };
            }

            const now = new Date();
            //special seed based on date
            //let myseed = now.getHours() * 60 + now.getMinutes();
            let myseed = now.getDay();
            const seededRandom = createSeededRandom(myseed);

            //How it works
            console.log(seededRandom()); // Random number between 0 and 1
            console.log(seededRandom()); // Next random number
            console.log(seededRandom()); // Next random number

            function fillBoard(board) {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === '') {
                            for (let num = 1; num <= 9; num++) {
                                const randomNum = Math.floor(seededRandom() * 9) + 1;
                                if (isValid(board, row, col, randomNum)) {
                                    board[row][col] = randomNum;
                                    if (fillBoard(board)) return true;
                                    board[row][col] = '';
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            }

            fillBoard(board);

            const puzzle = board.map(row => row.slice());
            const numCellsToRemove = 45;
            for (let i = 0; i < numCellsToRemove; i++) {
                const row = Math.floor(seededRandom() * 9);
                const col = Math.floor(seededRandom() * 9);
                puzzle[row][col] = '';
            }

            return { puzzle, solution: board };
        }

        const basePuzzles = Array.from({ length: 100 }, generateSudoku);

        let currentPuzzleIndex = Math.floor(Math.random() * basePuzzles.length);
        let incorrectAttempts = 0;
        let timer;
        let timeElapsed = 0;
        let maxHints = 50; // Set the maximum number of hints allowed
        let hintCount = 0; // Track the number of hints used

        function renderPuzzle(index) {
            const puzzle = basePuzzles[index].puzzle;
            const board = document.getElementById('sudoku-board');
            board.innerHTML = '';
            puzzle.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.maxLength = 3;
                    input.value = cell || '';
                    input.disabled = !!cell;
                    input.dataset.row = rowIndex;
                    input.dataset.col = colIndex;
                    input.addEventListener('input', handleInput);
                    board.appendChild(input);
                });
            });
            startTimer();
        }

        function startTimer() {
            if (timer) clearInterval(timer);
            timeElapsed = 0;
            document.getElementById('timer').innerText = `Time: ${timeElapsed}s`;
            timer = setInterval(() => {
                timeElapsed++;
                document.getElementById('timer').innerText = `Time: ${timeElapsed}s`;
            }, 1000);
        }

        function handleInput(event) {
            const input = event.target;
            const row = parseInt(input.dataset.row);
            const col = parseInt(input.dataset.col);
            const value = input.value ? parseInt(input.value) : null;
            const correctValue = basePuzzles[currentPuzzleIndex].solution[row][col];

            // Validate input is a single digit from 1-9
            if (!/^\d$/.test(input.value)) {
                input.value = "";
                return;
            }

            if (value === correctValue) {
                input.style.color = "#7fff00"; // Correct input turns green
                input.disabled = true; // Lock correct input
                checkCompletion(); // Check if the puzzle is completed
            } else if (value !== null) {
                input.value = "X"; // Clear incorrect value 
                incorrectAttempts++; // Increment incorrect attempt count
                document.getElementById('incorrect-attempts').innerText = `X's: ${incorrectAttempts}`;
            }
        }


        function giveHint() {
            const puzzle = basePuzzles[currentPuzzleIndex].puzzle;
            const solution = basePuzzles[currentPuzzleIndex].solution;

            // Get the current state of the board
            const inputs = document.querySelectorAll('input');
            let emptyCells = [];

            inputs.forEach(input => {
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);

                // Check if the cell is empty and not pre-filled
                if (!input.value && puzzle[row][col] === '') {
                    emptyCells.push({ row, col });
                }
            });

            if (emptyCells.length > 0 && hintCount < maxHints) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const hintValue = solution[randomCell.row][randomCell.col];
                const targetInput = Array.from(inputs).find(
                    input => input.dataset.row == randomCell.row && input.dataset.col == randomCell.col
                );

                if (targetInput) {
                    targetInput.value = hintValue;
                    targetInput.disabled = true; // Lock the hint in place
                    targetInput.classList.add("given"); // Optional: visually mark as a given cell
                }

                hintCount++;
                checkCompletion();
                document.getElementById('hint-button').innerText = `Hint (${maxHints - hintCount})`; // Update hint count

                if (hintCount >= maxHints) {
                    document.getElementById('hint-button').disabled = true; // Disable the button after reaching maxHints
                }
            }
        }

        function checkCompletion() {
            const cells = document.querySelectorAll("#sudoku-board input");
            const solution = basePuzzles[currentPuzzleIndex].solution;

            // Verify if all cells are filled correctly
            const isComplete = Array.from(cells).every(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                return cell.value == solution[row][col];
            });

            if (isComplete) {
                // Stop the timer
                clearInterval(timer);

                // Calculate the score
                const baseScore = 10000;
                const timePenalty = timeElapsed; // 1 point deducted per second
                const incorrectPenalty = incorrectAttempts * 10; // 10 points deducted per incorrect attempt
                const hintPenalty = hintCount * 500; // 500 points deducted per hint used

                const finalScore = Math.max(baseScore - timePenalty - incorrectPenalty - hintPenalty, 1);
                document.getElementById('timer').innerText = ` `;
                document.getElementById('incorrect-attempts').innerText = ` `;
                // Display completion message and score
                const scoreDisplay = document.getElementById("score");
                scoreDisplay.innerText = `ðŸŽ‰ Puzzle Complete! Score: ${finalScore}
                Time: ${timeElapsed}s, X's: ${incorrectAttempts}, Hints: ${hintCount}`;

                // Optionally disable further input
                cells.forEach(cell => cell.disabled = true);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            renderPuzzle(currentPuzzleIndex);

            document.getElementById('hint-button').addEventListener('click', giveHint);
            document.getElementById('restart-button').addEventListener('click', () => renderPuzzle(currentPuzzleIndex));
        });

    
        let selectedNumber = null;  // This will store the currently selected number

        // Function to render the Sudoku grid with inputs
        function renderPuzzle(index) {
            maxHints = 50; // Set the maximum number of hints allowed
            hintCount = 0; // Track the number of hints used
            incorrectAttempts = 0;
            document.getElementById('score').innerText = ` `;
            document.getElementById('incorrect-attempts').innerText = `Mistakes: 0`;
            document.getElementById('hint-button').innerText = `Hint (${maxHints - hintCount})`; // Update hint count
            const puzzle = basePuzzles[index].puzzle;
            const board = document.getElementById('sudoku-board');
            board.innerHTML = ''; // Clear previous board

            puzzle.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.maxLength = 1;
                    input.value = cell || ''; // Use the puzzle value if empty
                    input.disabled = !!cell; // Disable if it's a given cell
                    input.dataset.row = rowIndex;
                    input.dataset.col = colIndex;

                    // Add event listeners for input and focus events
                    input.addEventListener('input', handleInput);
                    input.addEventListener('focus', () => highlightCell(input)); // Add highlight on focus
                    input.addEventListener('blur', () => removeHighlight(input)); // Remove highlight on blur

                    board.appendChild(input);
                });
            });

            startTimer();
        }

        /////////Hightlight same numbers

        // Highlight the currently focused cell
        function highlightCell(input) {
            input.classList.add('highlighted');
        }

        // Remove highlight from a cell when focus is lost
        function removeHighlight(input) {
            input.classList.remove('highlighted');
        }

        // Function to handle number selection
        function handleNumberSelection(event) {
            // Get the selected number
            const selectedNumber = event.target.getAttribute('data-number');

            // Get all the cells in the board
            const cells = document.querySelectorAll('#sudoku-board input');

            // Toggle highlight on cells that match the selected number
            cells.forEach(cell => {
                if (cell.value === selectedNumber) {
                    // If the cell is already highlighted, remove the highlight
                    if (cell.classList.contains('highlighted')) {
                        cell.classList.remove('highlighted');
                    } else {
                        // Otherwise, add the highlight
                        cell.classList.add('highlighted');
                    }
                }
            });
        }

        // Attach event listeners to the number buttons
        const numberButtons = document.querySelectorAll('.number-button');
        numberButtons.forEach(button => {
            button.addEventListener('click', handleNumberSelection);
        });

        ///////Draft Mode

        let isDraftMode = false;

        // Toggle draft mode
        document.getElementById("draft-button").addEventListener("click", () => {
            isDraftMode = !isDraftMode;
            const draftButton = document.getElementById("draft-button");
            draftButton.innerText = isDraftMode ? "Draft" : "Draft";

            // Change the button color based on draft mode status
            if (isDraftMode) {
                draftButton.style.backgroundColor = 'rgb(65, 110, 212)'; // Blue color for draft mode
                draftButton.style.color = 'white'; // Ensure the text is readable
            } else {
                draftButton.style.backgroundColor = ''; // Reset button color
                draftButton.style.color = ''; // Reset text color
            }

            // When leaving draft mode, ensure the cells retain draft numbers but are editable
            if (!isDraftMode) {
                document.querySelectorAll("input").forEach(input => {
                    if (input.dataset.draft) {
                        input.value = input.dataset.draft; // Show draft numbers in the cell
                        input.style.color = "blue"; // Retain the visual indication for draft numbers
                    }
                });
            }
        });

        // Handle input
        function handleInput(event) {
            const input = event.target;
            const row = parseInt(input.dataset.row);
            const col = parseInt(input.dataset.col);
            const value = input.value.trim();
            const correctValue = basePuzzles[currentPuzzleIndex].solution[row][col];

            // Ensure the input container can store draft values
            if (!input.dataset.draft) input.dataset.draft = ""; // Initialize draft mode data

            if (isDraftMode) {
                input.style.color = "blue"; // Draft mode inputs are blue
                if (/^\d$/.test(value)) {
                    const currentDraft = input.dataset.draft.split("").filter(v => v !== "");
                    if (!currentDraft.includes(value) && currentDraft.length < 3) {
                        currentDraft.push(value); // Add the draft value
                        input.dataset.draft = currentDraft.join(""); // Update draft data
                        input.value = currentDraft.join(""); // Display draft numbers in the cell
                    }
                }
            } else {
                // Validate input is a single digit from 1-9
                if (!/^\d$/.test(value)) {
                    input.value = ""; // Clear invalid inputs
                    return;
                }

                if (parseInt(value) === correctValue) {
                    input.style.color = "#008000"; // Correct input turns green
                    input.disabled = true; // Lock correct input
                    input.dataset.draft = ""; // Clear any draft data
                    checkCompletion(); // Check if the puzzle is completed
                } else {
                    input.value = "X"; // Clear incorrect value
                    incorrectAttempts++; // Increment incorrect attempt count
                    document.getElementById('incorrect-attempts').innerText = `X's: ${incorrectAttempts}`;
                }
            }
        }

        // Handle key events for delete functionality
        document.querySelectorAll("input").forEach(input => {
            input.addEventListener("keydown", (event) => {
                if (!isDraftMode && event.key === "Delete") {
                    input.dataset.draft = ""; // Clear draft data
                    input.value = ""; // Clear input display
                    input.style.color = "black"; // Reset to normal color
                }
            });
        });

        // Keep drafted values intact when toggling draft mode
        document.getElementById("draft-button").addEventListener("click", () => {
            if (!isDraftMode) {
                document.querySelectorAll("input[data-draft]").forEach(input => {
                    if (input.dataset.draft) {
                        input.value = input.dataset.draft; // Retain drafted values
                        input.style.color = "blue"; // Keep draft values visually distinct
                    }
                });
            }
        });

    </script>
</body>
</html>
